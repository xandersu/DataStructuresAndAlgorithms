# 第3章 高级排序算法

### nLogn 比 n^2 快多少

|            | n^2   | nLogn   | faster / 倍 |
| ---------- | ----- | ------- | ----------- |
| n = 10     | 100   | 33      | 3           |
| n = 100    | 10000 | 664     | 15          |
| n = 1000   | 10^6  | 9966    | 100         |
| n = 10000  | 10^8  | 132877  | 753         |
| n = 100000 | 10^10 | 1660964 | 6020        |



## 归并排序 Merge Sort

首先分成一半

把左边的数组排序，把右边的数组排序

之后再将它们归并起来

分成一半后在分成一半，然后先排序再归并

再分半再归并

到一定细粒度后，就剩一个元素，不用排序就是有序的

然后进行归并，逐层归并



使用一块同样大的另外空间



时间复杂度O(nlogn)

O(N)的额外空间



## 3-4 自底向上的归并排序算法

迭代即可实现



## 快速排序 Quick Sort



[![Jv3TQP.png](https://s1.ax1x.com/2020/05/02/Jv3TQP.png)](https://imgchr.com/i/Jv3TQP)



### 算法步骤

1. 从数列中挑出一个元素，称为 "基准"（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；



选择一个元素，把他放到排好序后他应该在的位置，

对小于他的数组和大于他的数组进行快排

递归下去



通常使用第一个元素作为基准



## 双路快排



[![Jvr0xS.png](https://s1.ax1x.com/2020/05/02/Jvr0xS.png)](https://imgchr.com/i/Jvr0xS)



## 三路快排



[![Jvrn4x.png](https://s1.ax1x.com/2020/05/02/Jvrn4x.png)](https://imgchr.com/i/Jvrn4x)







### 分治算法

顾名思义，分而治之，就是将问题分割成同等结构的子问题，

之后将子问题逐一解决后，原问题也就得到了解决



快排和归并排序都用到了分治算法



### 求数组中的逆序数

### 求数组中的最大最小值

### 求数组中第n大元素











